<?php

declare(strict_types=1);

namespace MatthiasMullie\Scrapbook\Layered;

use MatthiasMullie\Scrapbook\KeyValueStore;

/**
 * This class will serve as a layered cache keyValueStore that fallbacks to lower
 * key-value stores to fetch the value. Unlike buffered store which is by
 * design "layering" only memory with an additional kv-store, this store
 * can layer an arbitrary number of kv-stores. Please use common sense.
 * An interesting usecase would be if you have precomputed data in a
 * file (flysystem?) or database and want to "lift" it to a faster store,
 * like redis or memcached.
 *
 * @author    Cornel Cruceru <cornel@cruceru.cc>
 * @copyright Copyright (c) 2024, Cornel Cruceru. All rights reserved
 * @license   LICENSE MIT
 */
class LayeredStore implements KeyValueStore
{
    /**
     * keyValueStore in order of use.
     *
     * @var KeyValueStore[]
     */
    protected array $keyValueStores = [];

    /**
     * @var LayeredStore[]
     */
    private array $collections = [];

    /**
     * For each valid keyValueStore you can configure a max lifetime
     *
     * @var int[]
     */
    private array $maxLifetimes = [];

    /**
     * Layered store takes a list of KeyValue stores and
     * a corresponding list of max lifetimes for each store
     *
     * @param KeyValueStore[] $keyValueStores
     * @param int[]           $maxLifetimes
     */
    public function __construct(array $keyValueStores, array $maxLifetimes = [])
    {
        foreach ($keyValueStores as $i => $keyValueStore) {
            if ($keyValueStore instanceof KeyValueStore) {
                $this->keyValueStores[] = $keyValueStore;
                $this->maxLifetimes[] = $maxLifetimes[$i] ?? PHP_INT_MAX;
            }
        }
    }

    private function _key_meta(mixed $key): string
    {
        if (!is_scalar($key)) {
            throw new \Exception('key is not scalar');
        }
        return $key . '-kvls-meta';
    }

    /**
     * Iterate through all stores and return a value if one is found
     * A token is generated by hashing the value to emulate cas
     *
     * {@inheritdoc}
     */
    public function get(string $key, mixed &$token = null): mixed
    {
        // Start with the first keyValueStore
        $value = false;
        
        $tokens = null;
        $result = $this->getMulti([$key], $tokens);
        $token = $tokens[$key] ?? null;
        $value = $result[$key] ?? false;

        return $value;
    }

    /**
     * Get multiple keys at once
     *
     * We could of course "foreach -> this->get" this but good storages
     * actually have a batch get capability (getMultiple in PSR16)
     * 
     * tokens are built the same as in get() : hash the seralized value
     *
     * {@inheritdoc}
     */
    public function getMulti(array $keys, ?array &$tokens = null): array
    {
        $keyValueStoreIndex = 0;
        $keyValueStoreValues = [];
        // start with no values and all keys marked as "missing"
        $wrappedValues = [];
        $missing = $keys;
        $missingMetas = array_map(fn($k) => $this->_key_meta($k), $keys);
        // keep track of keys we need to sync back up for each keyValueStore
        $syncback = [];
        // stop when we've found all the values or we're out of keyValueStores
        while (!empty($missing) && $keyValueStoreIndex < count($this->keyValueStores)) {
            // array_merge because we want to keep all the values
            $keyValueStoreValues[$keyValueStoreIndex] = $this->keyValueStores[$keyValueStoreIndex]->getMulti(array_merge($missing, $missingMetas));
            // gather all the values. we'll filter later
            // + operator is needed here to avoid renumbering integer keys (https://www.php.net/manual/en/function.array-merge.php)
            $wrappedValues = $wrappedValues + $keyValueStoreValues[$keyValueStoreIndex];
            // in $keyValueStoreValues we know what keys we found in this keyValueStore
            // so if there were keys missing we should sync them back
            // $syncback[$keyValueStoreIndex] = array_intersect($missing, array_keys($keyValueStoreValues[$keyValueStoreIndex]));
            $missing = array_diff($missing, array_keys($keyValueStoreValues[$keyValueStoreIndex]));
            $missingMetas = array_diff($missingMetas, array_keys($keyValueStoreValues[$keyValueStoreIndex]));

            $syncback[$keyValueStoreIndex] = $missing;
            if (!empty($missing)) {
                $keyValueStoreIndex++;
            }
        }

        $expires = [];
        $values = [];
        foreach ($wrappedValues as $key => $value) {
            if (in_array($key, $keys)) {
                $values[$key] = $value;
                $expires[$key] = $wrappedValues[$this->_key_meta($key)][1] ?? PHP_INT_MAX;
            }
        }

        // walk back and sync missing values
        while ($keyValueStoreIndex > 0) {
            $keyValueStoreIndex--;
            // this is best effort by design. no error handling
            // if sets fail then the keyValueStores will not have the
            // keys next time either so it's not a big deal
            $syncvalues = array_filter($values, fn($v, $k) => in_array($k, $syncback[$keyValueStoreIndex]), ARRAY_FILTER_USE_BOTH);
            if (!count($syncvalues)) {
                continue;
            }
            foreach ($syncvalues as $key => $value) {
                $this->keyValueStores[$keyValueStoreIndex]->set(
                    $key,
                    $value, 
                    $this->_getKeyValueStoreExpire($keyValueStoreIndex, $expires[$key])
                );
            }
        }

        $tokens = array_map(fn($e):string => md5(serialize($e)), $values);

        return $values;
    }

    /**
     * If expire > 30 days then just leave it alone. It is most likely an absolute
     * unix timestamp.
     * If expire <= 30 days then it's a relative TTL (lifetime) so we'll clamp it
     * to max lifetime for the keyValueStore 
     */
    private function _getKeyValueStoreExpire(int $keyValueStoreIndex, int $expire = 0)
    {
        if ($expire < 30 * 86400) {
            $expire = $expire === 0 ? $this->maxLifetimes[$keyValueStoreIndex] : min($expire, $this->maxLifetimes[$keyValueStoreIndex]);
        }

        return $expire;
        // return $expire > 2592000 ? $expire : min($expire, $this->maxLifetimes[$keyValueStoreIndex]);
    }

    private function _packValueExpire(mixed $value, int $expire = 0): array
    {
        return [$value, $expire];
    }

    private function _packValueExpireMulti(array $items, int $expire = 0): array
    {
        return array_map(fn($itemValue) => [$itemValue, $expire], $items);
    }

    /**
     * Set a key in all kv-stores.
     *
     * If a set fails a rollback will be attempted.
     * Rollback will delete the key from all kv-stores.
     * Rollback does not do error handling so some kv-stores
     * may endup having the key if the delete fails for whatever reason
     */
    public function set(string $key, mixed $value, int $expire = 0): bool
    {
        $result = $this->setMulti([$key => $value], $expire);

        return $result[$key] ?? false;
    }

    /**
     * Set multiple keys at once in all keyValueStores
     *
     * Starts with the last keyValueStore and walks back up.
     * This method tries to rollback if any keyValueStores fails
     * to set all the keys.
     * Rollback will remove all keys being set, not only the failed ones
     * Rollback is done with best effort so keys may be left behind
     */
    public function setMulti(array $items, int $expire = 0): array
    {
        $keyValueStoreIndex = count($this->keyValueStores);
        $results = array_fill_keys(array_keys($items), true); 
        $result = true;
        $keyMetas = array_fill_keys(array_map(fn($k) => $this->_key_meta($k), array_keys($items)), [time(), $expire]);
        while ($result && $keyValueStoreIndex > 0) {
            $keyValueStoreIndex--;
            $keyValueStoreResults = $this->keyValueStores[$keyValueStoreIndex]->setMulti(
                $items + $keyMetas,
                $this->_getKeyValueStoreExpire($keyValueStoreIndex, $expire)
            );
            array_walk($results, fn(&$r, $k) => $r = $r && $keyValueStoreResults[$k]);
            $result = array_reduce($results, fn($reduced, $r) => $reduced && $r, true);
        }
        //
        // if (!$result) {
        //     // best effort rollback
        //     while ($keyValueStoreIndex < count($this->keyValueStores)) {
        //         $this->keyValueStores[$keyValueStoreIndex++]->deleteMulti(array_keys($items));
        //     }
        // }

        return $results;
    }

    /**
     * Delete a key from all stores.
     *
     * Delete is done with best effort and no error handling
     * The result bool is an "and" operation on all keyValueStore results
     * It does not stop on failure which means the result may be false
     * but keys could be gone from all keyValueStores except one in the middle
     * It could also mean it's gone from all the keyValueStores but some did
     * not have the key anymore.
     */
    public function delete(string $key): bool
    {
        $keyValueStoreIndex = count($this->keyValueStores);
        $result = true;
        while ($keyValueStoreIndex > 0) {
            $keyValueStoreIndex--;
            $result = $result && $this->keyValueStores[$keyValueStoreIndex]->delete($key);
        }

        return $result;
    }


    /**
     * Delete multiple keys from all the stores
     */
    public function deleteMulti(array $keys): array
    {
        $keyValueStoreIndex = count($this->keyValueStores);
        $results = array_fill_keys($keys, true); 
        while ($keyValueStoreIndex > 0) {
            $keyValueStoreIndex--;
            $keyValueStoreResults = $this->keyValueStores[$keyValueStoreIndex]->deleteMulti($keys);
            array_walk($results, fn(&$r, $k) => $r = $r && $keyValueStoreResults[$k]);
        }

        return $results;
    }

    /**
     * Add a key to all stores.
     *
     * Emulated:
     * - check in the last store if we have it
     * - set it everywhere if we don't
     */ 
    public function add(string $key, mixed $value, int $expire = 0): bool
    {
        $keyValueStoreIndex = count($this->keyValueStores);
        $result = $this->keyValueStores[$keyValueStoreIndex-1]->get($key);
        if (false === $result) {
            return $this->set($key, $value, $expire);
        }

        return false;
    }

    /**
     * Replace a kay in all kv-stores.
     *
     * Emulated:
     * - check in the last store if we have it
     * - set it everywhere if we do have it
     */ 
    public function replace(string $key, mixed $value, int $expire = 0): bool
    {

        $keyValueStoreIndex = count($this->keyValueStores);
        $result = $this->keyValueStores[$keyValueStoreIndex-1]->get($key);
        if (false !== $result) {
            return $this->set($key, $value, $expire);
        }

        return false;
    }

    /**
     * check-and-set a key in all kv-stores
     *
     * CAS is emulated by hashing the stored value (md5)
     * If the value has changed since last get() then cas() will
     * return false.
     *
     * The get is done using layered get. This means that the first kv-store
     * that has the key will return a value that may match the token
     * but not all adapters necessarily have the same value.
     */
    public function cas(mixed $token, string $key, mixed $value, int $expire = 0): bool
    {
        $this->get($key, $currentToken);
        if ($token !== $currentToken || null === $token) {
            return false;
        }

        return $this->set($key, $value, $expire);
    }

    /**
     * Emulate increment:
     * - we'll always do the increment on the last layer and sync the value to
     *   the higher layers
     * - we need to reset the expiration
     */
    private function _increment(string $key, int $offset = 1, int $initial = 0, int $expire = 0): int|false
    {
        $keyValueStoreIndex = count($this->keyValueStores) - 1;

        $value = $this->keyValueStores[$keyValueStoreIndex]->get($key);
        if (false !== $value) {
            if (!is_numeric($value) || $value < 0) {
                return false;
            }
            $value = max(0, $value + $offset);
        } else {
            $value = $initial;
        }

        while ($keyValueStoreIndex >= 0) {
            $this->keyValueStores[$keyValueStoreIndex]->set(
                $key,
                $value, 
                $this->_getKeyValueStoreExpire($keyValueStoreIndex, $expire)
            );
            $keyValueStoreIndex--;
        }

        return $value;
    }

    public function increment(string $key, int $offset = 1, int $initial = 0, int $expire = 0): int|false
    {
        if ($offset <= 0 || $initial < 0) {
            return false;
        }

        return $this->_increment($key, $offset, $initial, $expire);
    }

    public function  decrement(string $key, int $offset = 1, int $initial = 0, int $expire = 0): int|false
    {
        if ($offset <= 0 || $initial < 0) {
            return false;
        }

        return $this->_increment($key, -$offset, $initial, $expire);
    }


    /**
     * Reset expiration on a key in all kv-stores
     */
    public function touch(string $key, int $expire): bool
    {
        $keyValueStoreIndex = count($this->keyValueStores);
        $result = true;
        while ($keyValueStoreIndex > 0) {
            $keyValueStoreIndex--;
            $result = $result && $this->keyValueStores[$keyValueStoreIndex]->touch($key, $this->_getKeyValueStoreExpire($keyValueStoreIndex, $expire));
        }

        return $result;
    }

    /**
     * Flush all kv-stores.
     *
     * First it flushes collection without error handling 
     *
     * Starts the flush from the last layer.
     * If upper layers fail to flush then keys may be returned
     * from those layers.
     */
    public function flush(): bool
    {
        foreach ($this->collections as $collection) {
            $collection->flush();
        }

        $keyValueStoreIndex = count($this->keyValueStores);
        $result = true;
        while ($keyValueStoreIndex > 0) {
            $keyValueStoreIndex--;
            $result = $result && $this->keyValueStores[$keyValueStoreIndex]->flush();
        }

        return $result;
    }

    /**
     * Build a layered store based on collections built for each kv-store.
     *
     * If each kv-store implements collection properly then this will return
     * a layered store of proper collections
     */
    public function getCollection(string $name): KeyValueStore
    {
        $keyValueStoreCollections = [];
        if (!isset($this->collections[$name])) {
            $keyValueStoreIndex = 0; 
            while ($keyValueStoreIndex < count($this->keyValueStores)) {
                $keyValueStoreCollections[$keyValueStoreIndex] = $this->keyValueStores[$keyValueStoreIndex]->getCollection($name);
                $keyValueStoreIndex++;
            }

            $this->collections[$name] = new static($keyValueStoreCollections, $this->maxLifetimes);
        }

        return $this->collections[$name];
    }
}
